我不会大扯什么原理，没意思，我这里只是记录一下规则而已，方便以后的查看。

# 规则

公有继承( **public** )、私有继承( **private** )、保护继承( **protected** )是常用的三种继承方式。

![规则表](http://upload-images。jianshu。io/upload_images/1918847-6d907f662467c175.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

三种继承方式有一些共同点 :

+ **父类中 private 类型的成员变量都会被子类继承(在子类的实例中占用空间)，但是子类是无法访问这些成员变量的，就像它们不存在一样。** 
+ **父类中 private 类型的成员函数在子类中也无法被调用，它们在某种意义上来说也是不存在的。**

下面是三种继承方式的不同点:

+  公有继承( **public** )

**父类中的 protected 和 public 类型的成员变量和函数类型不变地转移到子类中。**

+ 私有继承( **private** )

**父类的 protected 和 public 类型的成员变量和函数在子类中都变为了 private 类型。**

+ 保护继承( **protected** )

**父类的protected和public类型的成员变量和函数在子类中都变为了 protected 类型。**


# 什么东西不会被继承?

父类的 **构造函数** ，  **析构函数** ， **赋值函数** 不会被子类所继承的，事实上，继承这些东西也并没有什么用处。

上面提到的函数非常特殊，如果读过<<effective c++>>的话，我们会知道，在某些时候，即使类中没有定义这些函数，编译器也会自动为该类生成这些函数。

这里的某些时候指的是，代码中出现了相应的动作，如构造，赋值，拷贝等，而类中并没有定义对应的函数，当然，如果代码中没有出现这些动作，而且类中也没有定义对应的函数，编译器自然犯不着生成这些代码。

当然，这些编译器自动生成的代码只会做一些必要的动作。生成的普通的无参构造函数，嗯，如果存在父类的话，首先调用父类的无参构造函数，接下来什么也不干。对于拷贝构造函数和赋值函数，生成的代码做的事情基本上等价于逐bit拷贝。

子类在构造的时候， **首先会调用父类的构造函数(也许你并没有在初始化类表中显示地调用，或者你压根就没有定义构造函数，没关系，编译器会帮你调用父类的无参构造函数)，初始化完了父类的成员(不管是私有类型还是公有类型的)，然后才调用子类的构造函数来初始化子类的成员** 。

析构的时候，方向恰好相反， **首先调用子类的析构函数清理完子类中属于子类的那部分成员，然后调用父类的析构函数(编译器帮助我们生成的代码)，对子类中父类的部分做清理** 。

至于赋值操作， **如果子类不自己定义赋值函数，编译器也会为我们自动生成一个，它首先试图调用父类的赋值函数完成父类部分的赋值操作(父类中有定义了赋值函数就调用定义的赋值函数，没有的话就使用编译器为父类生成的赋值函数(其实就是逐bit拷贝而已))，然后逐bit拷贝子类中的子类部分**。

但是如果子类自己定义了赋值函数的话，编译器就不会插手赋值操作了，也就是说，如果你在赋值函数里没有完成对父类成员的赋值的话，那么这些成员就真的不会改变，千万不要认为编译器会帮我们调用父类的赋值函数，这是不可能的。

拷贝构造函数是很特殊的构造函数， 即使子类没有定义拷贝构造函数，编译器也会自动帮我们生成一个，生成的函数只会做一些必要的事情，基本上和上面的赋值操作一致， **如果父类定义了拷贝构造函数，首先调用父类的，然后逐bit拷贝子类部分。否则的话，直接逐bit拷贝**。

如果子类定义了拷贝构造函数的话，编译器也不会插手拷贝构造动作了。所以在拷贝构造函数里，请自己完成子类中父类部分和子类部分的构造，编译器是不会调用父类的拷贝构造函数的。