# slab介绍

内存分配与释放向来是程序设计中的难点，在C语言中有 **malloc** 可以方便使用，但还是有更多的针对具体业务的实现。内存分配需要考虑分配效率和内存使用率的平衡，当用户申请一块内存，程序需要在空闲内存中查找合适的内存块返回，这里可以选择一个最快获取的算法（ **first-fit** ），或者最优选择（ **best-fit** ）。二者往往无法两全。另外需要考虑一个根本性的问题就是内存碎片，释放内存时往往与申请顺序不同，会在内存中留下大量的空洞，当有大量不连续的小内存即碎片出现时，便会产生空闲内存很多但是无法分配大块内存的情况。对于操作系统，需要长时间运行，内存碎片的问题便显得非常突出了。

**Linux** 内核一种分配内存的方式是 **alloc_pages** ，使用伙伴算法，但这个只适用于按页分配，如果需要几个字节的内存都分配 **4k** ，显然会是极大的浪费，所以内核又提供了一种小内存的分配方式，称之为 **slab** ，另外还有两种可选的分配方式，**slob** 和 **slub** ， **slob** 是为了在嵌入式环境中使用，**slub** 在一些大型设备中比 **slab** 有更优秀的性能。但作为程序开发者来说，无需关心内核选用了哪种分配方式，三者具有相同的接口，调用者可以忽略其中的差别。

因为在内核中需要频繁分配同类型的对象，比如频繁分配 **socket** ， **task_struct** 等结构体对象， **slab** 一个核心思想就是一个 **slab** 分配器只分配一种对象，这样做的好处便是每个 **slab** 只分配等大小的内存，能够很好的兼顾效率和内存碎片的问题，当然 **slab** 最终也是通过 **alloc_pages** 按页分配的内存。

## slab的实现简介

**slab** 内存分配是一种用来高效管理内存的机制，可以避免频繁申请和释放内存带来的内存碎片问题， 同时提高内存分配效率。最早是在 Solaris 2.4的内核引入这个算法， 后面广泛应用在许多Unix和 类Unix(如FreeBSD)的操作系统上， 而在linux上直到2.6.23才成为默认的分配方式。 **slab** 分配最简单的理解,  **就是每次使用内存时，一次申请一片大内存，当需要使用内存时， 直接从slab分配，释放也是放回slab, 而不必从操作系统不断分配和释放** 。

为了可以重复分配和释放 **slab** 里面的 **item** , 我们一般将一个 **slab** 切分成长度相等的若干个 **item** , 比如有 **1M** 大小的 **slab** ，每个 **item** 是 **1024byte** , 那么该 **slab** 就被切分成 **1M/1024 = 1024** 个 **item** .

简单版的 **slab** 如下图所示:

![](./pic/slab_1.png)

当然,程序每次申请的空间长度不一定都是一样的，这里就需要引入不同 **item** 长度的 **slab** 啦 , 我们可以设定 **slabclass** 这样一种结构,它由具有相同长度 **item** 的 **slab** 构成。

为了搜索方便,可以采用数组或者链表的方式将不同的 **slabclass** 连接起来, 当然,这些 **slabclass** 应当根据其对应的的 **item** 的长度进行排序.这样,试图分配空间时，只需要遍历这个数组或者链表,就能很快找到对应 **item** 的长度和申请容量最相近的 **slabclass** ,然后从中找到一个未使用完或者空闲的 **slab** , 分配出一个 **item** 的空间。

下图是不同大小的 **slabclass** 构成的一个印象图. **slabclass** 对应图中绿色的大方块,  **item** 对应图中灰色的小方块. 这里并没有画出对应的 **slab**.

![](./pic/slabclass.png)

作为参考,我们可以采用这样的方式来决定每种 **slabclass** 的 **item** 的长度.

假定我们要产生 **n** 个不同的 **slabclass** , 每个 **slab** 的大小为 **1M** , 我们将第一级 **item** 长度设为 **100byte** , 然后设定一个增长因子 **p** ,此后的 **slabclass** 中的 **item** 的长度在前一级的基础上增长**p** 倍 。在下面的计算中,我们将增长因子设定为 **1.2** .

第一级 **item** 的长度为 **100bytes** ,每一个 **slab** 可以划分为 **1M/100** 个 **item** ;

第二级 **item** 的长度为 **100byte * 1.2 = 120byte** , 每一个 **slab** 可以划分为 **1M/120** 个 **item** ;

第三级 **item** 的长度为 **120byte * 1.2 = 144bytes** , 每一个 **slab** 可以划分为 **1M/144** 个 **item**.

依次类推.

当需要申请 **80byte** 的内存时候， 从第一级开始找，直到遇到第一个比它大的 **slab** , 这里就是第一级的 **slab** 。 如果要申请 **130bytes**的内存， 就是找到第三级.

看过上面的内容之后，应该能知道 **slab** 大概的样子，以及 **slabclass**是干嘛的。 **slabclass** 每一级的 **slab** 可以分配 的 **item** 长度和数量是固定的， 所以 **slab** 可能会有三种状态:  **free slab** (完全没有使用)，  **partial slab** (部分使用),  **full slab** (全部使用).

最开始, 由于没开始使用，只会有 **free slab** ， 当使用一段时间后，就转换为 **partial slab** , 如果这个 **slab** 已经被分配完， 则会变为 **full slab** .

我们可以在 **slabclass** 这个结构中,根据 **slab** 的状态,添加三个队列, 将这些处于不同状态的 **slab** 们连接起来, 这样的话,在实际分配空间的时候,搜寻起来也会方便很多.

如果采用上面的设计,当我们试图在某一级的 **slabclass** 中搜寻可用空间的时候,算法可以是这样的：

```shell
1. 如果这一级partial slab队列不为空， 先从这个队列里面取, 如果不为空，直接分配， 判断slab是满了，是？移到full slab队列。
2. 如果这一级parital slab队列为空， 从free slab队列获取一个slab, 放到这一级slab，重新分配。
```
当然,这只是一个简要的描述,当然,你不一定要采用上面的方法来实现你自己的 **slab** 内存分配器.

### slab空洞问题
如果频繁的分配,释放空间, 那么同一块slab中很可能会出现如下图所示的现象,那就是一块块内存被分配了,一块块内存没有被分配,这些内存块彼此交错,会导致下一次分配时搜索上的不方便.
![](./pic/slab_hole.png)



一个非常naive的解决方案是,将这些空的块拉成一张链表,这样下一次只需要从这张链表中取内存块即可.